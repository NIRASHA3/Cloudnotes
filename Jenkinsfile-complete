pipeline {
    agent any

    triggers {
        githubPush()
    }

    environment {
        // Docker Configuration
        DOCKER_REPO = 'nirashadeshani/cloudnotes'
        DOCKER_IMAGE_BACKEND = "${DOCKER_REPO}:backend"
        DOCKER_IMAGE_FRONTEND = "${DOCKER_REPO}:frontend"
        DOCKER_IMAGE_BACKEND_VERSIONED = ''
        DOCKER_IMAGE_FRONTEND_VERSIONED = ''
        DOCKERHUB_CREDENTIALS_ID = 'dockerhub-credentials'
        BACKEND_CONTAINER = 'cloudnotes-backend-prod'
        FRONTEND_CONTAINER = 'cloudnotes-frontend-prod'
        BACKEND_PORT = '5000'
        FRONTEND_PORT = '5173'
        
        // AWS Credentials
        AWS_ACCESS_KEY_ID = credentials('AWS_ACCESS_KEY_ID')
        AWS_SECRET_ACCESS_KEY = credentials('AWS_SECRET_ACCESS_KEY')
        AWS_DEFAULT_REGION = 'eu-north-1'
        
        // Application Credentials
        MONGO_URI = credentials('MONGO_URI')
        JWT_SECRET = credentials('JWT_SECRET')
        GOOGLE_CLIENT_ID = credentials('GOOGLE_CLIENT_ID')
        GOOGLE_CLIENT_SECRET = credentials('GOOGLE_CLIENT_SECRET')
        EMAIL_PASS = credentials('EMAIL_PASS')
        
        // Terraform workspace
        TF_WORKSPACE = 'dev'
    }

    parameters {
        booleanParam(name: 'RUN_TERRAFORM', defaultValue: true, description: 'Run Terraform to provision/update infrastructure (enable by default for auto-deployment)')
        booleanParam(name: 'RUN_SONARQUBE', defaultValue: false, description: 'Run SonarQube scan')
        booleanParam(name: 'RUN_TRIVY', defaultValue: true, description: 'Run Trivy image scan')
        booleanParam(name: 'RUN_CLEANUP', defaultValue: false, description: 'Cleanup Docker images after deployment')
    }

    stages {
        // ========================================
        // CI STAGES - Build, Test, Scan, Push
        // ========================================
        
        stage('Clone Repository') {
            steps {
                git branch: 'main', url: 'https://github.com/NIRASHA3/Cloudnotes.git'
            }
        }

        stage('Set Build Metadata') {
            steps {
                script {
                    def shortSha = (env.GIT_COMMIT ?: 'local').take(7)
                    env.IMAGE_TAG = "${env.BUILD_NUMBER}-${shortSha}"
                    env.DOCKER_IMAGE_BACKEND_VERSIONED = "${env.DOCKER_REPO}:backend-${env.IMAGE_TAG}"
                    env.DOCKER_IMAGE_FRONTEND_VERSIONED = "${env.DOCKER_REPO}:frontend-${env.IMAGE_TAG}"
                    echo "Using image tag: ${env.IMAGE_TAG}"
                }
            }
        }

        stage('Install Dependencies') {
            steps {
                dir('backend') {
                    sh 'rm -rf node_modules package-lock.json && npm install'
                }
                dir('frontend') {
                    sh 'rm -rf node_modules package-lock.json && npm install'
                }
            }
        }

        stage('Run Tests and Lint') {
            steps {
                dir('backend') {
                    sh 'npm test --if-present || echo "No backend tests found"'
                    sh 'npm run lint --if-present || echo "No backend linter configured"'
                }
                dir('frontend') {
                    sh 'npm test --if-present || echo "No frontend tests found"'
                    sh 'npm run lint --if-present || echo "No frontend linter configured"'
                }
            }
        }

        stage('Code Quality Scan (SonarQube)') {
            when {
                expression { return params.RUN_SONARQUBE }
            }
            steps {
                withSonarQubeEnv('SonarQube') {
                    sh '''
                        sonar-scanner \
                          -Dsonar.projectKey=cloudnotes \
                          -Dsonar.projectName=cloudnotes \
                          -Dsonar.sources=backend,frontend \
                          -Dsonar.javascript.lcov.reportPaths=backend/coverage/lcov.info,frontend/coverage/lcov.info \
                          -Dsonar.sourceEncoding=UTF-8
                    '''
                }
            }
        }

        stage('Build Docker Images') {
            steps {
                withEnv([
                    "DOCKER_REPO=${env.DOCKER_REPO}",
                    "DOCKER_IMAGE_BACKEND=${env.DOCKER_IMAGE_BACKEND}",
                    "DOCKER_IMAGE_FRONTEND=${env.DOCKER_IMAGE_FRONTEND}"
                ]) {
                    sh '''
                        SHORT_SHA=$(echo "${GIT_COMMIT:-local}" | cut -c1-7)
                        IMAGE_TAG="${IMAGE_TAG:-${BUILD_NUMBER}-${SHORT_SHA}}"
                        DOCKER_IMAGE_BACKEND_VERSIONED="${DOCKER_IMAGE_BACKEND_VERSIONED:-${DOCKER_REPO}:backend-${IMAGE_TAG}}"
                        DOCKER_IMAGE_FRONTEND_VERSIONED="${DOCKER_IMAGE_FRONTEND_VERSIONED:-${DOCKER_REPO}:frontend-${IMAGE_TAG}}"

                        echo "Building Docker images..."
                        echo "Backend image:  $DOCKER_IMAGE_BACKEND_VERSIONED"
                        echo "Frontend image: $DOCKER_IMAGE_FRONTEND_VERSIONED"
                        docker build -f Dockerfile.backend -t "$DOCKER_IMAGE_BACKEND_VERSIONED" -t "$DOCKER_IMAGE_BACKEND" .
                        docker build -f Dockerfile.frontend -t "$DOCKER_IMAGE_FRONTEND_VERSIONED" -t "$DOCKER_IMAGE_FRONTEND" .
                        echo "Docker images built successfully"
                    '''
                }
            }
        }

        stage('Security Scan (Trivy Images)') {
            when {
                expression { return params.RUN_TRIVY }
            }
            steps {
                withEnv([
                    "DOCKER_REPO=${env.DOCKER_REPO}"
                ]) {
                    sh '''
                        SHORT_SHA=$(echo "${GIT_COMMIT:-local}" | cut -c1-7)
                        IMAGE_TAG="${IMAGE_TAG:-${BUILD_NUMBER}-${SHORT_SHA}}"
                        DOCKER_IMAGE_BACKEND_VERSIONED="${DOCKER_IMAGE_BACKEND_VERSIONED:-${DOCKER_REPO}:backend-${IMAGE_TAG}}"
                        DOCKER_IMAGE_FRONTEND_VERSIONED="${DOCKER_IMAGE_FRONTEND_VERSIONED:-${DOCKER_REPO}:frontend-${IMAGE_TAG}}"

                        echo "Running Trivy image scans..."
                        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy:0.56.2 image --severity HIGH,CRITICAL "$DOCKER_IMAGE_BACKEND_VERSIONED" || echo "Trivy scan completed with findings"
                        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy:0.56.2 image --severity HIGH,CRITICAL "$DOCKER_IMAGE_FRONTEND_VERSIONED" || echo "Trivy scan completed with findings"
                    '''
                }
            }
        }

        stage('Push Docker Images') {
            steps {
                withEnv([
                    "DOCKER_REPO=${env.DOCKER_REPO}",
                    "DOCKER_IMAGE_BACKEND=${env.DOCKER_IMAGE_BACKEND}",
                    "DOCKER_IMAGE_FRONTEND=${env.DOCKER_IMAGE_FRONTEND}"
                ]) {
                    withCredentials([usernamePassword(credentialsId: DOCKERHUB_CREDENTIALS_ID, usernameVariable: 'DOCKERHUB_USERNAME', passwordVariable: 'DOCKERHUB_PASSWORD')]) {
                        sh '''
                            SHORT_SHA=$(echo "${GIT_COMMIT:-local}" | cut -c1-7)
                            IMAGE_TAG="${IMAGE_TAG:-${BUILD_NUMBER}-${SHORT_SHA}}"
                            DOCKER_IMAGE_BACKEND_VERSIONED="${DOCKER_IMAGE_BACKEND_VERSIONED:-${DOCKER_REPO}:backend-${IMAGE_TAG}}"
                            DOCKER_IMAGE_FRONTEND_VERSIONED="${DOCKER_IMAGE_FRONTEND_VERSIONED:-${DOCKER_REPO}:frontend-${IMAGE_TAG}}"

                            echo "Logging into Docker Hub..."
                            echo "$DOCKERHUB_PASSWORD" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin
                            
                            echo "Pushing versioned images..."
                            docker push "$DOCKER_IMAGE_BACKEND_VERSIONED"
                            docker push "$DOCKER_IMAGE_FRONTEND_VERSIONED"
                            
                            echo "Pushing latest tags..."
                            docker push "$DOCKER_IMAGE_BACKEND"
                            docker push "$DOCKER_IMAGE_FRONTEND"
                            
                            docker logout
                            echo "Images pushed to Docker Hub successfully"
                        '''
                    }
                }
            }
        }
        
        // ========================================
        // CD STAGES - Infrastructure & Deployment
        // ========================================
        
        stage('Terraform Init') {
            when {
                expression { return params.RUN_TERRAFORM }
            }
            steps {
                dir('terraform') {
                    sh '''
                        echo "Initializing Terraform..."
                        terraform init -input=false -no-color 2>&1 || true
                        echo "                        cat /root/cloudnotes/terraform/keys/cloudnotes-key.pemTerraform initialized"
                        echo "Using workspace: ${TF_WORKSPACE}"
                    '''
                }
            }
        }
        
        stage('Terraform Plan') {
            when {
                expression { return params.RUN_TERRAFORM }
            }
            steps {
                dir('terraform') {
                    script {
                        echo "Creating Terraform plan..."
                        
                        def instanceExists = sh(
                            script: 'terraform state list 2>/dev/null | grep aws_instance.cloudnotes_server || true',
                            returnStdout: true
                        ).trim()
                        
                        if (instanceExists) {
                            echo "Instance exists. Planning updates..."
                            sh 'terraform plan -out=tfplan -input=false -no-color -var-file=dev.tfvars'
                        } else {
                            echo "New infrastructure deployment..."
                            sh 'terraform plan -out=tfplan -input=false -no-color -var-file=dev.tfvars'
                        }
                    }
                }
            }
        }
        
        stage('Terraform Apply') {
            when {
                expression { return params.RUN_TERRAFORM }
            }
            steps {
                dir('terraform') {
                    sh '''
                        set -e
                        echo "Applying Terraform configuration..."

                        # Import existing AWS resources if they exist but are missing from state.
                        KEY_NAME="cloudnotes-key-dev"
                        SG_NAME="cloudnotes-sg-dev"

                        if ! terraform state list | grep -q '^aws_key_pair.cloudnotes_key$'; then
                            if aws ec2 describe-key-pairs --key-names "$KEY_NAME" >/dev/null 2>&1; then
                                echo "Importing existing key pair: $KEY_NAME"
                                terraform import aws_key_pair.cloudnotes_key "$KEY_NAME" || true
                            fi
                        fi

                        if ! terraform state list | grep -q '^aws_security_group.cloudnotes_sg$'; then
                            VPC_ID=$(aws ec2 describe-vpcs --filters Name=isDefault,Values=true --query 'Vpcs[0].VpcId' --output text)
                            SG_ID=$(aws ec2 describe-security-groups --filters Name=group-name,Values="$SG_NAME" Name=vpc-id,Values="$VPC_ID" --query 'SecurityGroups[0].GroupId' --output text)
                            if [ -n "$SG_ID" ] && [ "$SG_ID" != "None" ]; then
                                echo "Importing existing security group: $SG_NAME ($SG_ID)"
                                terraform import aws_security_group.cloudnotes_sg "$SG_ID" || true
                            fi
                        fi

                        # Recreate the plan because imports can change state and stale the previous plan.
                        terraform plan -no-color -out tfplan -var-file=dev.tfvars
                        terraform apply -auto-approve -no-color tfplan
                        
                        echo "=== Terraform Outputs ==="
                        terraform output -no-color -json
                        
                        SERVER_IP=$(terraform output -no-color -raw public_ip)
                        echo "Server IP: $SERVER_IP"
                    '''
                }
            }
        }
        
        stage('Get Server IP') {
            steps {
                dir('terraform') {
                    script {
                        env.SERVER_IP = sh(
                            script: 'terraform output -no-color -raw public_ip 2>/dev/null || echo "13.51.227.34"',
                            returnStdout: true
                        ).trim()
                        echo "Target server: ${env.SERVER_IP}"
                        currentBuild.description = "Deploying to: ${env.SERVER_IP}"
                    }
                }
            }
        }
        
        stage('Configure Ansible Inventory') {
            steps {
                dir('ansible') {
                    withCredentials([
                        sshUserPrivateKey(credentialsId: 'cloudnotes-ssh-key', keyFileVariable: 'SSH_KEY_FILE', usernameVariable: 'SSH_USER')
                    ]) {
                        sh """
                        echo "Configuring Ansible inventory for \${SERVER_IP}..."

                        mkdir -p ../terraform/keys
                        mkdir -p inventory

                        cp "${SSH_KEY_FILE}" ../terraform/keys/cloudnotes-key.pem
                        chmod 600 ../terraform/keys/cloudnotes-key.pem

                        cat > inventory/hosts.yml << 'ANSIBLE_EOF'
all:
  children:
    project_CloudNotes:
      hosts:
        cloudnotes_server:
          ansible_host: ${SERVER_IP}
          ansible_user: ${SSH_USER}
          ansible_ssh_private_key_file: ../terraform/keys/cloudnotes-key.pem
          ansible_python_interpreter: /usr/bin/python3
ANSIBLE_EOF
                        
                        echo "Ansible inventory created"
                        cat inventory/hosts.yml
                        """
                    }
                }
            }
        }
        
        stage('Deploy to EC2 with Ansible') {
            steps {
                dir('ansible') {
                    withCredentials([
                        string(credentialsId: 'MONGO_URI', variable: 'MONGO_URI'),
                        string(credentialsId: 'JWT_SECRET', variable: 'JWT_SECRET'),
                        string(credentialsId: 'GOOGLE_CLIENT_ID', variable: 'GOOGLE_CLIENT_ID'),
                        string(credentialsId: 'GOOGLE_CLIENT_SECRET', variable: 'GOOGLE_CLIENT_SECRET'),
                        string(credentialsId: 'EMAIL_PASS', variable: 'EMAIL_PASS')
                    ]) {
                        sh '''
                            set -e
                            
                            echo "=========================================="
                            echo "DEPLOYING WITH ANSIBLE"
                            echo "=========================================="
                            echo "Target: ${SERVER_IP}"
                            echo ""
                            
                            # Setup Ansible environment
                            export ANSIBLE_HOST_KEY_CHECKING=False
                            export ANSIBLE_DEPRECATION_WARNINGS=False
                            
                            echo "Installing Ansible collections..."
                            ansible-galaxy collection install -r requirements.yml 2>&1 | tail -5 || true
                            
                            echo ""
                            echo "Testing SSH connectivity..."
                            ansible all -i inventory/hosts.yml -m ping -v || {
                                echo "SSH connectivity check failed, retrying in 10 seconds..."
                                sleep 10
                                ansible all -i inventory/hosts.yml -m ping -v
                            }
                            
                            echo ""
                            echo "Running Ansible playbook to deploy application..."
                            export MONGO_URI="${MONGO_URI}"
                            export JWT_SECRET="${JWT_SECRET}"
                            export GOOGLE_CLIENT_ID="${GOOGLE_CLIENT_ID}"
                            export GOOGLE_CLIENT_SECRET="${GOOGLE_CLIENT_SECRET}"
                            export EMAIL_PASS="${EMAIL_PASS}"
                            
                            ansible-playbook playbook.yml -i inventory/hosts.yml -v
                            
                            echo ""
                            echo "Ansible playbook completed successfully"
                        '''
                    }
                }
            }
        }
        
        stage('Verify Deployment') {
            steps {
                sh '''
                    echo "=========================================="
                    echo "VERIFYING DEPLOYMENT"
                    echo "=========================================="
                    echo "Target: ${SERVER_IP}"
                    echo ""
                    
                    echo "Waiting for services to start..."
                    sleep 10
                    
                    echo "Testing frontend (port 5173)..."
                    if timeout 10 curl -s -f -o /dev/null -w "HTTP %{http_code}\\n" http://${SERVER_IP}:5173 2>/dev/null; then
                        echo "Frontend is responding"
                    else
                        echo "Frontend not available yet (services may still be starting)"
                    fi
                    
                    echo ""
                    echo "Testing backend (port 5000)..."
                    if timeout 10 curl -s -f -o /dev/null -w "HTTP %{http_code}\\n" http://${SERVER_IP}:5000 2>/dev/null; then
                        echo "Backend is responding"
                    else
                        echo "Backend not available yet (services may still be starting)"
                    fi
                    
                    echo ""
                    echo "Checking Docker containers on remote server..."
                    ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 -o BatchMode=yes -i terraform/keys/cloudnotes-key.pem ubuntu@${SERVER_IP} "docker ps --filter 'name=cloudnotes' --format 'table {{.Names}}\\t{{.Status}}'" 2>/dev/null || echo "⚠ Could not verify containers via SSH"
                    
                    echo ""
                    echo "=========================================="
                '''
            }
        }

        stage('Cleanup Docker (Jenkins Agent)') {
            when {
                expression { return params.RUN_CLEANUP }
            }
            steps {
                sh '''
                    echo "Cleaning up Docker resources on Jenkins agent..."
                    docker container prune -f
                    docker image prune -f
                    docker volume prune -f
                '''
            }
        }
    }

    post {
        always {
            script {
                def status = currentBuild.result ?: 'IN PROGRESS'
                def duration = currentBuild.durationString ?: 'Running...'
                def timestamp = sh(script: "date '+%Y-%m-%d %H:%M:%S'", returnStdout: true).trim()

                echo ''
                echo '=========================================='
                echo 'PIPELINE SUMMARY'
                echo '=========================================='
                echo "Build: #${env.BUILD_NUMBER}"
                echo "Status: ${status}"
                echo "Duration: ${duration}"
                echo "Timestamp: ${timestamp}"
                
                try {
                    dir('terraform') {
                        def serverIp = sh(
                            script: 'terraform output -no-color -raw public_ip 2>/dev/null || echo "13.51.227.34"',
                            returnStdout: true
                        ).trim()
                        
                        echo """
========================================
APPLICATION ACCESS
========================================
Frontend:  http://${serverIp}:5173
Backend:   http://${serverIp}:5000
API:       http://${serverIp}:5000/api/auth/google

========================================
DOCKER IMAGES
========================================
Backend:  ${env.DOCKER_IMAGE_BACKEND_VERSIONED ?: 'Not set'}
Frontend: ${env.DOCKER_IMAGE_FRONTEND_VERSIONED ?: 'Not set'}

Docker Hub: https://hub.docker.com/r/nirashadeshani/cloudnotes/

========================================
REMOTE SERVER MANAGEMENT
========================================
SSH Access:
  ssh -i terraform/keys/cloudnotes-key.pem ubuntu@${serverIp}

View Logs:
  ssh ubuntu@${serverIp} "docker logs -f cloudnotes-backend"
  ssh ubuntu@${serverIp} "docker logs -f cloudnotes-frontend"

Restart Services:
  ssh ubuntu@${serverIp} "cd cloudnotes && docker-compose restart"

Redeploy:
  Jenkins Trigger: Rebuild this job
  
========================================
"""
                    }
                } catch (Exception e) {
                    echo "Could not retrieve deployment details: ${e.message}"
                }
            }
        }

        success {
            echo '=================================='
            echo '✅ PIPELINE COMPLETED SUCCESSFULLY'
            echo '=================================='
            echo 'All stages passed!'
            echo 'Application is now live and ready for use.'
        }

        failure {
            echo '=================================='
            echo '❌ PIPELINE FAILED'
            echo '=================================='
            echo 'Check the logs above for details.'
            sh '''
                echo "Cleaning up Docker resources on Jenkins agent..."
                docker container prune -f 2>/dev/null || true
                docker image prune -f 2>/dev/null || true
            '''
        }
    }
}
